<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Strange Attractor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0b0c0f;
    color: #ccc;
    font-family: 'Inter', system-ui, sans-serif;
    overflow: hidden;
    height: 100vh;
  }
  #attractor {
    position: fixed;
    inset: 0;
    z-index: 0;
  }
  #attractor canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  .overlay {
    position: fixed;
    z-index: 10;
    pointer-events: none;
  }
  .parameters {
    bottom: 24px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    gap: 16px;
    pointer-events: auto;
  }
  .parameters code {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    padding: 6px 14px;
    font-size: 14px;
    font-family: 'JetBrains Mono', monospace;
    color: #aaa;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s;
  }
  .parameters code:hover,
  .parameters code.active {
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.25);
    color: #fff;
  }
  .parameters code sub {
    font-size: 10px;
    color: #666;
    margin-left: 4px;
  }
  .position {
    top: 24px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    gap: 16px;
  }
  .position code {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: #555;
  }
  .position code sub {
    font-size: 9px;
    color: #444;
    margin-left: 2px;
  }
  .hint {
    bottom: 70px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 11px;
    color: #333;
    transition: opacity 0.5s;
  }
</style>
</head>
<body>

<div id="attractor"></div>

<div class="overlay position" id="position"></div>
<div class="overlay parameters" id="parameters"></div>
<div class="overlay hint" id="hint">click a parameter & use ↑↓ to adjust · drag to orbit · scroll to zoom · ctrl+P pause · ctrl+E export</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ── Constants ──────────────────────────────────────────────────────
const CA = 4;
const OC = 0.05 / CA;
const TRAIL_POINTS = 256 * CA;   // 1024 points per spline
const NUM_SPLINES = 100;
const BG = 0x0b0c0f;

// ── Attractor parameters (reactive state) ──────────────────────────
const params = {
  alpha:   0.95,
  beta:    0.2,
  gamma:   0.7,
  delta:   3.5,
  epsilon: 0.25,
  zeta:    0.1,
};

// ── Renderer setup ─────────────────────────────────────────────────
const container = document.getElementById('attractor');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(BG);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.75;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(BG);
scene.fog = new THREE.Fog(BG, 1, 6);

const camera = new THREE.PerspectiveCamera(90, 1, 1e-4, 1000);
camera.position.z = 1;

// ── Post-processing ────────────────────────────────────────────────
const rtSize = new THREE.Vector2(window.innerWidth * 2, window.innerHeight * 2);
const rt = new THREE.WebGLRenderTarget(rtSize.x, rtSize.y, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.LinearFilter,
  format: THREE.RGBAFormat,
  samples: 4,
});
const composer = new EffectComposer(renderer, rt);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth * devicePixelRatio, window.innerHeight * devicePixelRatio),
  1, 0.25, 0
));

// ── Controls ───────────────────────────────────────────────────────
const controls = new OrbitControls(camera, renderer.domElement);
controls.minDistance = 0;
controls.maxDistance = 2000;
controls.rotateSpeed = 1.5;

// ── Spline Trails ──────────────────────────────────────────────────
const colorA = new THREE.Color(0xffc120);
const colorB = new THREE.Color(0xff8a8c);
const group = new THREE.Group();

const splines = [];
for (let i = 0; i < NUM_SPLINES; i++) {
  const position = new Float32Array(TRAIL_POINTS * 3);
  const geometry = new THREE.BufferGeometry();

  // random starting point
  position[0] = Math.random() - 0.5;
  position[1] = Math.random() - 0.5;
  position[2] = Math.random() - 0.5;

  const color = new THREE.Color().copy(colorA).lerp(colorB, Math.random());
  const material = new THREE.LineBasicMaterial({
    color,
    blending: THREE.AdditiveBlending,
    transparent: true,
    opacity: 0.5 + (Math.random() - 0.5) * 0.4,
    fog: true,
  });

  const line = new THREE.Line(geometry, material);
  line.frustumCulled = false;
  group.add(line);
  splines.push({ position, geometry });
}
scene.add(group);

// ── Integration step ───────────────────────────────────────────────
function integrate(spline, p) {
  const { alpha, beta, delta, gamma, zeta } = p;
  const a = p.epsilon / CA;
  const pos = spline.position;
  const x = pos[0], y = pos[1], z = pos[2];

  const dx = OC * ((z - beta) * x - delta * y);
  const dy = OC * (delta * x + (z - beta) * y);
  const dz = OC * (gamma + alpha * z - Math.pow(z, 3) / 3
    - (Math.pow(x, 2) + Math.pow(y, 2)) * (1 + a * z)
    + zeta * z * Math.pow(x, 3));

  // shift trail back, prepend new point
  pos.copyWithin(3, 0, 3 * TRAIL_POINTS - 3);
  pos[0] = x + dx;
  pos[1] = y + dy;
  pos[2] = z + dz;
}

function updateSplines() {
  for (const spline of splines) {
    integrate(spline, params);
    const attr = new THREE.BufferAttribute(spline.position, 3);
    spline.geometry.setAttribute('position', attr);
  }
}

// warm up
for (let i = 0; i < 1200; i++) updateSplines();

// ── Camera Animation ───────────────────────────────────────────────
function lerp3(a, b, t) {
  return new THREE.Vector3(
    a.x + (b.x - a.x) * t,
    a.y + (b.y - a.y) * t,
    a.z + (b.z - a.z) * t,
  );
}

// easeInOutCubic
function ease(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

const keyframes = [
  { len: 500,  from: { pos: [-1.607, 1.473, -2.630], tgt: [0.141, -0.100, 0.850] }, to: { pos: [-1.170, 1.245, -2.715], tgt: [0.147, -0.070, 0.859] }},
  { len: 1500, from: { pos: [0.063, 1.284, -0.828], tgt: [0.063, 0.002, -0.828] }, to: { pos: [-0.012, 0.847, -1.859], tgt: [-0.012, 0.008, -1.864] }},
  { len: 1500, from: { pos: [0, 2.397, 0], tgt: [0, 0, 0] }, to: { pos: [0, 2.376, 0], tgt: [0, 0, 0] }},
  { len: 1000, from: { pos: [-1.578, 0.030, -1.482], tgt: [0, 0, 0] }, to: { pos: [-1.288, -0.009, -1.012], tgt: [0, 0, 0] }},
  { len: 1000, from: { pos: [0, 0, 2.220], tgt: [0, 0, 0] }, to: { pos: [0, 0, 2.048], tgt: [0, 0, 0] }},
  { len: 500,  from: { pos: [0.999, 1.324, -2.867], tgt: [0.019, 0.195, 0.106] }, to: { pos: [1.676, 0.795, -2.717], tgt: [0.019, 0.195, 0.106] }},
  { len: 1000, from: { pos: [0.004, 0.171, -1.563], tgt: [-0.026, 0, 0] }, to: { pos: [0, 0.052, -1.154], tgt: [-0.026, 0, 0] }},
  { len: 1000, from: { pos: [-0.838, 0.602, -0.157], tgt: [-1.456, -0.347, -2.544] }, to: { pos: [-0.568, 0.451, -0.414], tgt: [-1.456, -0.347, -2.544] }},
];

let kfIndex = 0, kfProgress = 0;

function animateCamera() {
  const kf = keyframes[kfIndex];
  const t = ease(kfProgress / kf.len);

  const pos = lerp3(
    new THREE.Vector3(...kf.from.pos),
    new THREE.Vector3(...kf.to.pos), t);
  const tgt = lerp3(
    new THREE.Vector3(...kf.from.tgt),
    new THREE.Vector3(...kf.to.tgt), t);

  camera.position.copy(pos);
  controls.target.copy(tgt);

  kfProgress++;
  if (kfProgress >= kf.len) {
    kfProgress = 0;
    kfIndex = (kfIndex + 1) % keyframes.length;
  }
}

// ── Resize ─────────────────────────────────────────────────────────
function resize() {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
}
window.addEventListener('resize', resize);
resize();

// ── UI: Parameters ─────────────────────────────────────────────────
const paramDefs = [
  { key: 'alpha',   sym: 'α' },
  { key: 'beta',    sym: 'β' },
  { key: 'gamma',   sym: 'γ' },
  { key: 'delta',   sym: 'δ' },
  { key: 'epsilon', sym: 'ε' },
  { key: 'zeta',    sym: 'ζ' },
];

let activeParam = null;
const paramEl = document.getElementById('parameters');

function renderParams() {
  paramEl.innerHTML = paramDefs.map(({ key, sym }) =>
    `<code class="${activeParam === key ? 'active' : ''}" data-key="${key}">${params[key].toFixed(3)}<sub>${sym}</sub></code>`
  ).join('');

  paramEl.querySelectorAll('code').forEach(el => {
    el.addEventListener('click', () => {
      activeParam = activeParam === el.dataset.key ? null : el.dataset.key;
      renderParams();
    });
  });
}
renderParams();

window.addEventListener('keydown', (e) => {
  if (activeParam && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
    e.preventDefault();
    const delta = e.key === 'ArrowUp' ? 0.01 : -0.01;
    params[activeParam] += delta;
    renderParams();
  }
});

// ── UI: Position ───────────────────────────────────────────────────
const posEl = document.getElementById('position');
function renderPosition() {
  const p = camera.position;
  posEl.innerHTML =
    `<code>${p.x.toFixed(3)}<sub>x</sub></code>` +
    `<code>${p.y.toFixed(3)}<sub>y</sub></code>` +
    `<code>${p.z.toFixed(3)}<sub>z</sub></code>`;
}

// ── Keyboard shortcuts ─────────────────────────────────────────────
let paused = false;
window.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key.toLowerCase() === 'p') {
    e.preventDefault();
    paused = !paused;
  }
  if (e.ctrlKey && e.key.toLowerCase() === 'e') {
    e.preventDefault();
    const canvas = container.querySelector('canvas');
    const link = document.createElement('a');
    link.download = `attractor-${canvas.width}-${canvas.height}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
});

// fade hint after 6s
setTimeout(() => { document.getElementById('hint').style.opacity = '0'; }, 6000);

// ── Main loop ──────────────────────────────────────────────────────
function loop() {
  requestAnimationFrame(loop);
  if (!paused) {
    updateSplines();
    animateCamera();
  }
  controls.update();
  composer.render();
  renderPosition();
}
loop();
</script>
</body>
</html>
